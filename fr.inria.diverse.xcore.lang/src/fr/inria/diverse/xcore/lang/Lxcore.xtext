// automatically generated by Xtext
grammar fr.inria.diverse.xcore.lang.Lxcore with org.eclipse.xtext.xbase.Xbase

import "platform:/resource/fr.inria.diverse.xcore/model/Lcore.ecore#/" 
import "http://www.eclipse.org/emf/2002/Ecore"
import "http://www.eclipse.org/xtext/xbase/Xbase" as xbase
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as javaVMTypes
import "http://www.eclipse.org/xtext/xbase/Xtype" as xtype
import "http://www.eclipse.org/emf/2002/GenModel" as genmodel

XPackage returns XPackage:
	{XPackage}
	'package'
	name = QualifiedName
	(importDirectives += XImportDirective)*
	(classifiers += XClassifier)*
;

XImportDirective returns XImportDirective : 
	{XImportDirective}
	'import' (importedNamespace=QualifiedNameWithWildcard | importedObject=[EObject|QualifiedName])
;


XClassifier returns XClassifier : 
	XClass |
	XDataType |
	XEnum
;

XDataType returns XDataType:
	'type' name = ID
	('<' typeParameters+=XTypeParameter (',' typeParameters+=XTypeParameter)* '>')?
	'wraps' instanceType=JvmTypeReference
	(
	  /*
	   * In scope for create should be what's visible in XyzFactoryImpl and 'this' will denote the literal value.
	   * The block expression must yield null or an instance of the wrapped type.
	   */
	  (serializable?='create' createBody=XBlockExpression)? &
	  /*
	   * In scope for create should be what's visible in XyzFactoryImpl
	   * and 'this' will denote an instance of the wrapped type.
	   * The block expression must yield a java.lang.String.
	   */
	  ('convert' convertBody=XBlockExpression)?
	)
;

XEnum returns XEnum:
	'enum' name = ID
	'{'
	  (literals+=XEnumLiteral ((',')? literals+=XEnumLiteral)*)?
	'}'
;

XEnumLiteral returns XEnumLiteral:
    name=ID
    ('as' literal=STRING)?
    ('=' value=SignedInt)?
;

SignedInt returns EInt :
	'-'? INT
;

XClass returns XClass:
	{XClass}
	((abstract?='abstract'? 'class') | interface?= 'interface') name = ID
	('<' typeParameters+=XTypeParameter (',' typeParameters+=XTypeParameter)* '>')?
	('extends' superTypes+=XGenericType (',' superTypes+=XGenericType)*)?
	('wraps' instanceType=JvmTypeReference) ?
	'{'
	   (members+=XMember)*
	'}'
;

XMember returns XMember:
	XOperation |
	XAttribute |
	XReference
;

XAttribute returns XAttribute:
	{XAttribute}
	(
	  (unordered?='unordered')? &
	  (unique?='unique')? &
	  (readonly?='readonly')? &
	  (transient?='transient')? &
	  (volatile?='volatile')? &
	  (unsettable?='unsettable')? &
	  (derived?='derived')? &
	  (iD?='id')?
	)
    name=ID
    type=XGenericType
    ('=' defaultValueLiteral=STRING)?
	/*
	 * In scope for getBody should be what's visible in AbcImpl
	 * and 'this' will denote an instance of the feature's type.
	 * The block expression must yield a value of the feature's type.
	 */
	(('get' getBody=XBlockExpression)? &
	 ('set' setBody=XBlockExpression)? &
	 ('isSet' isSetBody=XBlockExpression)? &
	 ('unset' unsetBody=XBlockExpression)?)
;

XReference returns XReference:
	{XReference}
	((containment?='contains' resolveProxies?='resolving'?) |
	 (resolveProxies?='resolving' containment?='contains') |
	 (container?='container' resolveProxies?='resolving'?) |
	 (resolveProxies?='resolving' container?='container') |
	 ('refers' local?='local'?) |
	 (local?='local' 'refers'))
	(
	  (unordered?='unordered')? &
	  (unique?='unique')? &
	  (readonly?='readonly')? &
	  (transient?='transient')? &
	  (volatile?='volatile')? &
	  (unsettable?='unsettable')? &
	  (derived?='derived')?
	)
	type=XGenericType
    name=ID
	/*
	 * In scope for getBody should be what's visible in AbcImpl
	 * and 'this' will denote an instance of the feature's type.
	 * The block expression must yield a value of the feature's type.
	 */
	(('get' getBody=XBlockExpression)? &
	 ('set' setBody=XBlockExpression)? &
	 ('isSet' isSetBody=XBlockExpression)? &
	 ('unset' unsetBody=XBlockExpression)?)
;

XOperation returns XOperation:
	{XOperation}
	'op'
	(
	  unordered?='unordered' unique?='unique'? |
	  unique?='unique' unordered?='unordered'?
	)?
	('<' typeParameters+=XTypeParameter (',' typeParameters+=XTypeParameter)* '>')?
	(type=XGenericType | 'void')
	name=ID
	'(' (parameters+=XParameter (',' parameters+=XParameter)*)? ')'
	('throws' exceptions+=XGenericType (',' exceptions+=XGenericType)*)?
	/*
	 * This is the logic for the operation.
	 * How are we going to resolve all references that are in scope for Xbase language?
	 * Will things like variables that are actually there in generated in the Impl class be accessible directly?
	 */
	(body=XBlockExpression)?
;

XParameter returns XParameter:
	(
	  unordered?='unordered' unique?='unique'? |
	  unique?='unique' unordered?='unordered'?
	)?
    type=XGenericType
    name=ID
;

XTypeParameter returns XTypeParameter :
	name=ID ('extends' bounds+=XGenericType ('&' bounds+=XGenericType)*)?
;
	
XGenericType returns XGenericType:
  type=[genmodel::GenBase] (=>'<' typeArguments+=XGenericTypeArgument (',' typeArguments+=XGenericTypeArgument)* '>')?
;

XGenericTypeArgument returns XGenericType :
	XGenericType |
	XGenericWildcardTypeArgument
;

XGenericWildcardTypeArgument returns XGenericType :
   {XGenericType}
   '?' ('extends' upperBound=XGenericType | 'super' lowerBound=XGenericType)?
;
@Override 
XBlockExpression returns xbase::XBlockExpression:
 {xbase::XBlockExpression}
 '{'
  (expressions+=XExpressionOrVarDeclaration ';'?)*
 '}'
;

XQualifiedName:
	XID ('.' XID)*
;

XID:
	ID | 'get' | 'isSet' | 'set' | 'unset'
;

@Override 
ValidID:
	XID | 'void'
;

@Override 
FeatureCallID:
	ValidID | 'abstract' | 'annotation' | 'as' | 'class' | 'container' | 'contains' | 'convert' | 'create' | 'derived' | 'enum' | 'extends' | 'extension' | 'id' | 'import' | 'keys' |
	'interface'| 'local' | 'op' | 'opposite' | 'package' | 'readonly' | 'refers' | 'resolving' | 'static' | 'throws' | 'transient' | 'unique' | 'unordered' | 'unsettable'|
	'volatile' | 'wraps'
;